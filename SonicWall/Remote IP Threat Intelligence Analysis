make_col path:lower(string(EXTRA.path))
filter
  contains(path, "sonic")
  or contains(path, "sonicwall")
  or lower(string(FIELDS.vendor)) = "sonicwall"
  or lower(string(FIELDS["neqter.type"])) = "sonicwall"

make_col sw:object(parse_json(FIELDS.value))
make_col src:sw.source

make_table
pick_col
  RawRemote:string(src.source.address),
  SrcIP:string(src.source.address),
  DstIP:string(src.destination.address),
  SrcRole:string(src.source.zone.role),
  DstRole:string(src.destination.zone.role),
  SrcIf:string(src.source.interface),
  DstIf:string(src.destination.interface),
  Service:string(src.network.protocol)

// Derive RemoteIP from WAN-side; avoid null literals
make_col src_if_l:lower(string(SrcIf)), dst_if_l:lower(string(DstIf)), src_role_l:lower(string(SrcRole)), dst_role_l:lower(string(DstRole))
make_col src_is_wan:(src_role_l = "wan" or src_if_l = "x1"),
        dst_is_wan:(dst_role_l = "wan" or dst_if_l = "x1")

make_col
  RemoteIP:string(coalesce(
    if(src_is_wan, SrcIP, ""),
    if(dst_is_wan, DstIP, ""),
    RawRemote,
    DstIP,
    SrcIP
  )),
  DestinationIP:DstIP

filter not is_null(RemoteIP) and RemoteIP != "" and not is_null(DestinationIP)

// --- Geo lookup table (collapsed) ---
@city_ipv4_v2_sq <- @city_ipv4{
  statsby
    network_start:any_not_null(network_start),
    network_end:any_not_null(network_end),
    country_name:last_not_null(country_name),
    city_name:last_not_null(city_name),
    subdivision_1_name:last_not_null(subdivision_1_name),
    group_by(network)
  add_key network_start, network_end
}

// --- RemoteIP → Geo ---
@remote_geo <- @{
  make_col rem_net:parse_ip(RemoteIP)
  filter int64(rem_net.family) = 4
  make_col ipv4_int:int64(rem_net.ip_fields[0])
  join
    on(ipv4_int >= @city_ipv4_v2_sq.network_start and ipv4_int <= @city_ipv4_v2_sq.network_end),
    rem_country:@city_ipv4_v2_sq.country_name,
    rem_city:@city_ipv4_v2_sq.city_name,
    rem_state:@city_ipv4_v2_sq.subdivision_1_name
  statsby
    RemCountry:any_not_null(rem_country),
    RemCity:any_not_null(rem_city),
    RemState:any_not_null(rem_state),
    group_by(RemoteIP)
}

// --- DestinationIP → Geo ---
@dst_geo <- @{
  make_col dst_net:parse_ip(DestinationIP)
  filter int64(dst_net.family) = 4
  make_col ipv4_int:int64(dst_net.ip_fields[0])
  join
    on(ipv4_int >= @city_ipv4_v2_sq.network_start and ipv4_int <= @city_ipv4_v2_sq.network_end),
    dst_country:@city_ipv4_v2_sq.country_name,
    dst_city:@city_ipv4_v2_sq.city_name,
    dst_state:@city_ipv4_v2_sq.subdivision_1_name
  statsby
    DstCountry:any_not_null(dst_country),
    DstCity:any_not_null(dst_city),
    DstState:any_not_null(dst_state),
    group_by(DestinationIP)
}

// Attach geo to rows
leftjoin
  on(RemoteIP=@remote_geo.RemoteIP),
  RemCountry:@remote_geo.RemCountry,
  RemCity:@remote_geo.RemCity,
  RemState:@remote_geo.RemState

leftjoin
  on(DestinationIP=@dst_geo.DestinationIP),
  DstCountry:@dst_geo.DstCountry,
  DstCity:@dst_geo.DstCity,
  DstState:@dst_geo.DstState

// Aggregate with enhanced threat intelligence
aggregate group_by(RemoteIP, RemCountry, RemCity, RemState),
  Events:count(),
  UniqueDestinations:count_distinct(DestinationIP),
  UniqueServices:count_distinct(Service),
  DestinationCountries:count_distinct(DstCountry)

// Calculate threat indicators
make_col ThreatScore:case(
  UniqueDestinations > 50 and UniqueServices > 10, "HIGH_SCANNING",
  UniqueDestinations > 20 and UniqueServices > 5, "MODERATE_SCANNING", 
  UniqueDestinations > 10, "POTENTIAL_SCANNING",
  UniqueServices > 5, "SERVICE_PROBING",
  true, "NORMAL"
)

make_col ActivityPattern:case(
  DestinationCountries > 3, "GLOBAL_TARGETING",
  UniqueDestinations = 1 and Events > 100, "FOCUSED_ATTACK",
  UniqueServices = 1 and UniqueDestinations > 10, "SERVICE_SCANNING",
  true, "MIXED_ACTIVITY"
)

sort desc(Events), desc(UniqueDestinations)
