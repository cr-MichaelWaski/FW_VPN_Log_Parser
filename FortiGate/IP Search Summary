make_col path:lower(string(EXTRA.path))
filter contains(string(path), "converted")

make_table
pick_col
// =========================
// TIER 1 — CORE EVENT CONTEXT
// =========================
//Timestamp:string(FIELDS.timestamp),
//Timestamp:string(replace(replace(FIELDS.timestamp, "T", " "), "Z", "")),
    Date:string(FIELDS.date),
    Time:string(FIELDS.time),
    DateTime:string(FIELDS.date) + " " + string(FIELDS.time),
    Action:string(FIELDS.action),
    LogType:string(FIELDS.type),
    SubType:string(FIELDS.subtype),
    LogDescription:string(FIELDS.logdesc),
    VPNUser:string(FIELDS.user),
    RemoteIP:string(FIELDS.remip),
    SourceIP:string(FIELDS.srcip),
    DestinationIP:string(FIELDS.dstip),
    DestinationHost:string(FIELDS.dst_host),
    Service:string(FIELDS.service),
    Protocol:string(FIELDS.proto),
    Outcome:string(FIELDS.reason),
    Message:string(FIELDS.message),

    // =========================
    // TIER 2 — VPN & TRAFFIC CONTEXT
    // =========================
    VPNGroup:string(FIELDS.group),
    TunnelID:string(FIELDS.tunnelid),
    TunnelType:string(FIELDS.tunneltype),
    VPNMsg:string(FIELDS.msg),
    SourcePort:string(FIELDS.srcport),
    DestinationPort:string(FIELDS.dstport),
    SourceInterface:string(FIELDS.srcintf),
    SourceInterfaceRole:string(FIELDS.srcintfrole),
    DestinationInterface:string(FIELDS.dstintf),
    DestinationInterfaceRole:string(FIELDS.dstintfrole),
    SourceCountry:string(FIELDS.srccountry),
    DestinationCountry:string(FIELDS.dstcountry),
    DestinationMAC:string(FIELDS.dstmac),

    // =========================
    // TIER 3 — POLICY, SESSION, TRANSLATION
    // =========================
    PolicyID:string(FIELDS.policyid),
    PolicyName:string(FIELDS.policyname),
    PolicyType:string(FIELDS.policytype),
    PolicyUUID:string(FIELDS.poluuid),
    SessionID:string(FIELDS.sessionid),
    TranslatedIP:string(FIELDS.tranip),
    TranslatedPort:string(FIELDS.tranport),
    TranslationDisposition:string(FIELDS.trandisp),
    ReceivedBytes:int64(FIELDS.rcvdbyte),
    SentBytes:int64(FIELDS.sentbyte),
    ReceivedPackets:int64(FIELDS.rcvdpkt),
    SentPackets:int64(FIELDS.sentpkt),

    // =========================
    // TIER 4 — SYSTEM & GRAYLOG METADATA
    // =========================
    DeviceName:string(FIELDS.devname),
    DeviceID:string(FIELDS.devid),
    SourceDevice:string(FIELDS.dstdevtype),
    LogID:string(FIELDS.logid),
    LogLevel:string(FIELDS.level),
    EventTime:string(FIELDS.eventtime),
    Timezone:string(FIELDS.tz),
    VirtualDomain:string(FIELDS.vd),
    Facility:string(FIELDS.facility),
    FacilityNum:string(FIELDS.facility_num),

    // Graylog-specific ingestion metadata
    GL2MessageID:string(FIELDS.gl2_message_id),
    GL2AccountedMessageSize:int64(FIELDS.gl2_accounted_message_size),
    GL2ProcessingTimestamp:string(FIELDS.gl2_processing_timestamp),
    GL2ReceiveTimestamp:string(FIELDS.gl2_receive_timestamp),
    GL2ProcessingDuration:int64(FIELDS.gl2_processing_duration_ms),
    GL2RemoteIP:string(FIELDS.gl2_remote_ip),
    GL2RemotePort:string(FIELDS.gl2_remote_port),
    GL2SourceInput:string(FIELDS.gl2_source_input),
    GL2SourceNode:string(FIELDS.gl2_source_node),
    RAW:FIELDS

dedup

// Target IP identification using extracted columns (your corrected version)
make_col target_ip_found: case(
    string(SourceIP) = "91.92.241.179" or string(SourceIP) = "64.190.113.235" or
    string(SourceIP) = "216.219.95.234" or string(SourceIP) = "157.250.195.229" or
    string(SourceIP) = "64.94.84.85" or string(SourceIP) = "96.62.214.11" or
    string(SourceIP) = "49.12.69.80", "SOURCE_MATCH",
    string(DestinationIP) = "91.92.241.179" or string(DestinationIP) = "64.190.113.235" or
    string(DestinationIP) = "216.219.95.234" or string(DestinationIP) = "157.250.195.229" or
    string(DestinationIP) = "64.94.84.85" or string(DestinationIP) = "96.62.214.11" or
    string(DestinationIP) = "49.12.69.80", "DEST_MATCH",
    string(RemoteIP) = "91.92.241.179" or string(RemoteIP) = "64.190.113.235" or
    string(RemoteIP) = "216.219.95.234" or string(RemoteIP) = "157.250.195.229" or
    string(RemoteIP) = "64.94.84.85" or string(RemoteIP) = "96.62.214.11" or
    string(RemoteIP) = "49.12.69.80", "REMOTE_MATCH",
    true, "NO_MATCH"
    )

// Get the actual target IP value
make_col target_ip: case(
    target_ip_found = "SOURCE_MATCH", SourceIP,
    target_ip_found = "DEST_MATCH", DestinationIP,
    target_ip_found = "REMOTE_MATCH", RemoteIP,
    true, "NO_MATCH"
    )

// Filter to only show target IPs
filter target_ip_found != "NO_MATCH"

// Calculate data flow direction for each IP
make_col data_in_bytes: case(
    target_ip_found = "DEST_MATCH", SentBytes,  // When target is destination, incoming data
    target_ip_found = "SOURCE_MATCH", ReceivedBytes,  // When target is source, data they received from us
    true, 0
)

make_col data_out_bytes: case(
    target_ip_found = "SOURCE_MATCH", SentBytes,  // When target is source, outgoing data  
    target_ip_found = "DEST_MATCH", ReceivedBytes,  // When target is destination, data they sent back
    true, 0
)

// Summary aggregation by IP
aggregate group_by(target_ip),
  first_seen_in_log: min(DateTime),
  last_seen_in_logs: max(DateTime),
  total_events: count(),
  data_in_total: sum(data_in_bytes),
  data_out_total: sum(data_out_bytes)

// ───────── Geo + ASN Lookup Tables ─────────

// MaxMind Geo DB
@city_ipv4_v2_sq <- @city_ipv4{
  statsby
    network_start:any_not_null(network_start),
    network_end:any_not_null(network_end),
    country_name:last_not_null(country_name),
    city_name:last_not_null(city_name),
    subdivision_1_name:last_not_null(subdivision_1_name),
    group_by(network)
  add_key network_start, network_end
}

// ASN DB
@asn_ipv4_v2_sq <- @asn_ipv4{
  statsby
    network_start:any_not_null(network_start),
    network_end:any_not_null(network_end),
    autonomous_system_organization:last_not_null(autonomous_system_organization),
    group_by(network)
  add_key network_start, network_end
}

// Map target_ip → Geo + ASN
@target_geo <- @{
  filter not is_null(target_ip)
  make_col ip:parse_ip(target_ip)
  filter int64(ip.family) = 4
  make_col ipv4:int64(ip.ip_fields[0])

  join
    on(ipv4 >= @city_ipv4_v2_sq.network_start and ipv4 <= @city_ipv4_v2_sq.network_end),
    Country:@city_ipv4_v2_sq.country_name,
    City:@city_ipv4_v2_sq.city_name,
    State:@city_ipv4_v2_sq.subdivision_1_name

  join
    on(ipv4 >= @asn_ipv4_v2_sq.network_start and ipv4 <= @asn_ipv4_v2_sq.network_end),
    ASN:@asn_ipv4_v2_sq.autonomous_system_organization

  statsby
    Country:any_not_null(Country),
    City:any_not_null(City),
    State:any_not_null(State),
    ASN:any_not_null(ASN),
    group_by(target_ip)
}

// ───────── Attach Geo Data ─────────
leftjoin
  on(target_ip=@target_geo.target_ip),
  Country:@target_geo.Country,
  City:@target_geo.City,
  State:@target_geo.State,
  ASN:@target_geo.ASN

// Convert bytes to MB for readability
make_col data_in_mb: data_in_total / (1024 * 1024)
make_col data_out_mb: data_out_total / (1024 * 1024)

// Create final summary columns matching your headers
make_col IP: target_ip
make_col first_seen_in_log: first_seen_in_log
make_col last_seen_in_logs: last_seen_in_logs
make_col data_in: case(
    data_in_mb < 0.01, "<0.01 MB",
    data_in_mb < 1, string(round(data_in_mb, 2)) + " MB",
    data_in_mb < 1024, string(round(data_in_mb, 1)) + " MB", 
    true, string(round(data_in_mb / 1024, 2)) + " GB"
)
make_col data_out: case(
    data_out_mb < 0.01, "<0.01 MB",
    data_out_mb < 1, string(round(data_out_mb, 2)) + " MB",
    data_out_mb < 1024, string(round(data_out_mb, 1)) + " MB",
    true, string(round(data_out_mb / 1024, 2)) + " GB"
)

// Sort by first seen
sort first_seen_in_log

// Display summary table with geolocation
pick_col IP, Country, City, ASN, first_seen_in_log, last_seen_in_logs, data_in, data_out
